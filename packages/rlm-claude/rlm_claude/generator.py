"""
ClaudeMdGenerator - Auto-generate CLAUDE.md documentation

Uses RLM to analyze the codebase and generate comprehensive
documentation for Claude Code/AI assistants.
"""

import os
import sys
from pathlib import Path
from datetime import datetime
from typing import Optional
from dotenv import load_dotenv

# Add RLM to path
RLM_PATH = Path(__file__).parent.parent.parent / "rlm"
if str(RLM_PATH) not in sys.path:
    sys.path.insert(0, str(RLM_PATH))

from rlm import RLM

load_dotenv()


CLAUDE_MD_TEMPLATE = '''# {project_name}

> Auto-generated by RLM-Claude on {timestamp}

## Overview

{overview}

## Architecture

{architecture}

## Key Components

{components}

## Directory Structure

```
{directory_structure}
```

## Tech Stack

{tech_stack}

## Development

### Setup
{setup}

### Key Commands
{commands}

## API Reference

{api_reference}

## Important Files

{important_files}

## Common Tasks

{common_tasks}
'''


class ClaudeMdGenerator:
    """
    Generates CLAUDE.md documentation using RLM analysis.
    """
    
    DEFAULT_PROJECT_ROOT = Path("/Users/tomas/apps/beethoven")
    
    def __init__(
        self,
        project_root: Optional[Path] = None,
        model: str = "anthropic/claude-sonnet-4.5",
        verbose: bool = True,
    ):
        self.project_root = Path(project_root or self.DEFAULT_PROJECT_ROOT)
        self.model = model
        self.verbose = verbose
        
        self.api_key = os.getenv("OPENROUTER_API_KEY")
        if not self.api_key:
            raise ValueError("OPENROUTER_API_KEY not found")
    
    def _get_rlm(self) -> RLM:
        """Create RLM instance."""
        return RLM(
            backend="openrouter",
            backend_kwargs={
                "api_key": self.api_key,
                "model_name": self.model,
            },
            environment="local",
            environment_kwargs={},
            max_depth=1,
            max_iterations=20,
            verbose=self.verbose,
        )
    
    def _load_codebase_summary(self) -> str:
        """Load a summary of the codebase for the prompt."""
        from .indexer import CodebaseIndexer
        
        indexer = CodebaseIndexer(self.project_root)
        index = indexer.index()
        
        # Build summary
        lines = [
            f"Project: {self.project_root.name}",
            f"Files: {index.total_files}",
            f"Lines: {index.total_lines:,}",
            "",
            "=== FILE TREE ===",
            indexer.get_file_tree(max_depth=2),
            "",
            "=== KEY FILES ===",
        ]
        
        # Add key file contents
        key_patterns = [
            "package.json", "pyproject.toml", "README.md",
            "convex/schema.ts", "app/layout.tsx", "main.py"
        ]
        
        for pattern in key_patterns:
            matches = indexer.search_files(pattern)
            for match in matches[:1]:  # First match only
                file_path = self.project_root / match
                if file_path.exists():
                    content = file_path.read_text()[:2000]  # First 2000 chars
                    lines.append(f"\n--- {match} ---")
                    lines.append(content)
        
        return "\n".join(lines)
    
    def generate(self, output_path: Optional[Path] = None) -> str:
        """
        Generate CLAUDE.md documentation.
        
        Args:
            output_path: Where to save the file (default: project_root/CLAUDE.md)
            
        Returns:
            Generated markdown content
        """
        output_path = output_path or (self.project_root / "CLAUDE.generated.md")
        
        codebase_summary = self._load_codebase_summary()
        
        # Generate each section using RLM
        sections = {}
        
        prompts = {
            "overview": "Analyze this codebase and write a 2-3 paragraph overview explaining what the project does, its main purpose, and key features. Be specific about this project, not generic.",
            
            "architecture": "Describe the architecture of this project. Include the main layers (frontend, backend, database), how they communicate, and key design patterns used. Use bullet points.",
            
            "components": "List the 5-10 most important components/modules in this codebase. For each, give a brief description of what it does and where it's located.",
            
            "tech_stack": "List the main technologies used in this project as a bullet list. Include frameworks, databases, APIs, and key libraries with version numbers where visible.",
            
            "setup": "Write setup instructions for a new developer. Include environment setup, dependencies, and how to run the project locally.",
            
            "commands": "List the most important development commands (npm/pnpm scripts, python commands, etc.) as a code block with comments.",
            
            "api_reference": "Document the main API endpoints or functions that developers would need to know. Include parameters and return types where visible.",
            
            "important_files": "List 10-15 of the most important files in this codebase that a developer should understand first. For each, explain what it does in one sentence.",
            
            "common_tasks": "List 5-10 common development tasks and how to accomplish them. Examples: adding a new API endpoint, creating a component, running tests.",
        }
        
        rlm = self._get_rlm()
        
        for section, prompt in prompts.items():
            if self.verbose:
                print(f"\nüîç Generating section: {section}...")
            
            full_prompt = f"""You are documenting the following codebase:

{codebase_summary}

TASK:
{prompt}

INSTRUCTIONS:
- Use the REPL to explore the codebase if needed
- Be specific to THIS project, not generic
- Reference actual file names and code when relevant
- Keep the output concise but informative
- Use markdown formatting

Return your answer with FINAL(your_markdown_content)"""

            try:
                result = rlm.completion(full_prompt)
                answer = result.response
                
                # Handle tuple responses
                if isinstance(answer, tuple):
                    answer = f"[See analysis above]"
                
                # Clean up FINAL() wrapper if present
                if answer.startswith("FINAL(") and answer.endswith(")"):
                    answer = answer[6:-1]
                
                sections[section] = answer
                
            except Exception as e:
                if self.verbose:
                    print(f"  ‚ö†Ô∏è Error generating {section}: {e}")
                sections[section] = f"*Error generating this section: {e}*"
        
        # Get directory structure
        from .indexer import CodebaseIndexer
        indexer = CodebaseIndexer(self.project_root)
        directory_structure = indexer.get_file_tree(max_depth=2)
        
        # Assemble the document
        content = CLAUDE_MD_TEMPLATE.format(
            project_name=self.project_root.name.title(),
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M"),
            overview=sections.get("overview", ""),
            architecture=sections.get("architecture", ""),
            components=sections.get("components", ""),
            directory_structure=directory_structure,
            tech_stack=sections.get("tech_stack", ""),
            setup=sections.get("setup", ""),
            commands=sections.get("commands", ""),
            api_reference=sections.get("api_reference", ""),
            important_files=sections.get("important_files", ""),
            common_tasks=sections.get("common_tasks", ""),
        )
        
        # Save to file
        output_path.write_text(content)
        
        if self.verbose:
            print(f"\n‚úÖ Generated: {output_path}")
        
        return content
